<!-- 객체 지향 프로그래밍
        : 좀 더 나은 프로그램을 만들기 위한 프로그래밍 패러다임
        : 로직을 상태(state)와 행위(behave)로 이루어진 객체로 만드는 것
        : 객체들을 마치 레고 블럭처럼 조립해서 하나의 프로그램을 만드는 것
        : 따라서, 객체를 만드는 것
        : 연관된 메소드와 그 메소드가 사용하는 변수들을 문류하고 그룹핑하는 것, 그렇게 그룹핑 한 대상이 객체(Object)임
            - (e.g) 객체 = 폴더 디렉토리 
                    메소드, 변수 = 파일 
        
        - (특정) 1개의 객체 (재활용이 가능한 ^^)는 아래 변수와 메소드를 포함하는 그룹핑이고 다른 곳에도 일종에 "부품"으로서 활용되어서 재활용성을 높인다. 
            - (특정) 변수
            - (특정) 메소드
--> 


<!-- 추상화
    : 객체지향 프로그래밍은 좀 더 현실을 잘 반영하기 위한 노력의 산물이므로, 따라서 추상화의 능력이 필ㅇ

    : 객체 지향 프로그래밍 교육은 두가지로 구분됨
        1. 문법
            - 객체지향을 편하게 할 수 있도록 언어가 제공하는 기능을 익히는 것
            - if, for문처럼 문법적인 구성을 가지고 있다 
        2. 설계
            - 좋은 객체를 만드는 법
            - 설계를 잘하는 법
            - 좋은 설계는 현실을 잘 반영해야 함
            - 현실을 복잡하다
            - 하지만, 그 복잡함 전체가 필요한 것은 아니다 ! 
            우리가 필요로 하는 것만을 표출해서 복잡한 현실을 (추상화해서) 간단하게 만들어 나타내는 것 
                => (소프트웨어의) 추상화(abstract)
                    - e.g) 지도맵
-->


<!-- 부품화
    : 객체지향은 부품화의 정점이라고 할 수 있다. 
    : 객체(로직)는 재활용가능하도록 부품화 된 것이다. 
-->


<!-- 은닉화, 캡슐화
    : 제대로 된 부품이라면, 그것이 어떻게 만들어졌는지 모르는 사람도 그 부품을 사용하는 방법만 알면 쓸 수 있어야 한다.
    : 예를 들면, 모니터가 어떻게 동작하는지는 몰라도, 컴퓨터와 모니터를 연결하는 방법만 알면 화면을 표시할 수 있는 것과 같은 이치
    : 즉, 내부의 동작 방법(객체)을 단단한 케이스 안으로 숨기고, 사용자에게는 그 부품의 사용 방법(메소드의 사용법)만을 노출하고 있는 것
    : 이것을 정보의 은닉화 (information hiding) 또는 캡슐화 (Encapsulation) 이라고 부른다.
-->


<!-- 인터페이스 
    : 잘 만들어진 부품이라면 부품과 부품을 서로 교환할 수 있어야 한다.
    : 예를 들면, 내 컴퓨터에 A사의 모니터를 연결하다가 B사의 모니터를 연결할 수 있다.  
    : 따라서, 모니터와 컴퓨터는 서로 교환관계에 있다.
    : 이것은, 모니터와 컴퓨터를 연결하는 케이블(HDMI)의 규격이 '표준화'되어 있기 때문에 가능하다
    : 컴퓨터와 모니터는 각각 서로가 어떻게 만들어졌는지 신경쓰지 않는다.
    : 각각의 부품은 미리 정해진 약속에 따라 신호를 입,출력하고 연결점의 모양을 표준에 맞게 만들면 된다.
    : 이러한 연결점을 '인터페이스(interface)'라고 하며, 동질적인 것을 결합해주고, 이질적인 것들이 결합하는 것을 막아주는 역할을 한다. 
    : 따라서, 인터페이스는 부품들 간의 약속이다. 
-->
